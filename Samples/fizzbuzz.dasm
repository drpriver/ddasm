dlimport LibC
  "libc.so.6"
  "libSystem.B.dylib"
   atoi 1 1
   puts 1 1 
   printf 1 1 varargs
end


import io
function start 0
    move rbp rsp
    move rs0 rsp
    move rout1 rarg1
    cmp rarg1 0
    cmov ne rip label validate

    add rsp rsp 80
    move rarg1 rs0
    move rarg2 80
    move rarg3 "N (for fizzbuzz): "
    call function io.getline 3

    move rarg1 rs0
    call function LibC.atoi 1

    label validate

    # validate the input a bit
    move rs1 rout1
    cmp rs1 1
    jump ge label notsmall
    move rarg1 "Too Small!"
    call function LibC.puts 1
    halt

    label notsmall
    cmp rs1 100000
    jump le label notbig
    move rarg1 "Too big!"
    call function LibC.puts 1
    halt

    label notbig
    move rarg1 rs1
    add rarg1 rarg1 1
    move rarg2 1
    call function fizzbuzz 1
    halt
end

function fizzbuzz 1
        # rarg8 as scratch reg
        move     rarg8 rarg1
        move    rs0 1

    label begin_loop
    # In this loop, we use rs3 to track whether we have printed
    # a word or not.
        move    rs3 0
        div     rjunk rs1 rs0 3
        cmp     rs1 0
        move    rarg1 ""
        cmov eq rarg1 "\e[91mfizz"
        cmov eq rs3 1
        call function LibC.printf 1

        div     rjunk rs1 rs0 5
        cmp     rs1 0
        move    rarg1 ""
        cmov eq rarg1 "\e[92mbuzz"
        cmov eq rs3 1
        call function LibC.printf 1
        cmp     rs3 1
        jump eq label skip_number

        move    rarg1 "\e[94m%u"
        # varargs use the stack
        push    rs0
        call function LibC.printf 2
        pop     rs0

    label skip_number
        move    rarg1 " "
        call function LibC.printf 1

        add     rs0 rs0 1
        cmp     rs0 rarg8
        jump ne label begin_loop

        move rarg1 "\e[39m" # reset
        call function LibC.puts 1
        ret
end

function recursive_fizzbuzz 1
    cmp rarg1 rarg2
    jump eq label end
    push rarg1
    push rarg2
    move rs0 rarg2

    move    rs3 0
    div     rjunk rs1 rs0 3
    cmp     rs1 0
    move    rarg1 ""
    cmov eq rarg1 "\e[91mfizz"
    cmov eq rs3 1
    call function LibC.printf 1

    div     rjunk rs1 rs0 5
    cmp     rs1 0
    move    rarg1 ""
    cmov eq rarg1 "\e[92mbuzz"
    cmov eq rs3 1
    call function LibC.printf 1
    cmp     rs3 1
    jump eq label skip_number2

    move    rarg1 "\e[94m%u"
    push rs0
    call function LibC.printf 2
    pop rs0

label skip_number2
    move    rarg1 " "
    call function LibC.printf 1
    pop rarg2
    pop rarg1
    add rarg2 rarg2 1
    tail_call function recursive_fizzbuzz

    label end
    move rarg1 "\e[39m" # reset
    call function LibC.puts 1
    bt
    ret
end
